
## 1. Что такое React?

**React** — это JavaScript-библиотека с открытым исходным кодом, разработанная компанией Facebook (Meta) в 2013 году для создания пользовательских интерфейсов. React является одной из самых популярных библиотек для фронтенд-разработки.

### Основные характеристики React:

- **Декларативный подход**: Вы описываете, как должен выглядеть интерфейс в определенном состоянии, а React заботится о том, как обновить DOM
- **Компонентно-ориентированная архитектура**: Приложение строится из небольших, переиспользуемых компонентов
- **Однонаправленный поток данных**: Данные передаются от родительских компонентов к дочерним
- **Виртуальный DOM**: Повышает производительность за счет оптимизации обновлений реального DOM

### Почему React популярен:

- Высокая производительность благодаря Virtual DOM
- Большое сообщество разработчиков
- Богатая экосистема библиотек и инструментов
- Поддержка со стороны Meta
- Возможность использования для мобильной разработки (React Native)

## 2. Цели и задачи React

### Основные цели React:

**Упрощение разработки сложных пользовательских интерфейсов**

- Разбивка сложного интерфейса на маленькие, управляемые компоненты
- Повторное использование компонентов в разных частях приложения

**Повышение производительности**

- Минимизация операций с DOM через Virtual DOM
- Эффективное обновление только изменившихся частей интерфейса

**Улучшение опыта разработчика**

- Декларативный синтаксис делает код более читаемым
- Горячая перезагрузка для быстрой разработки
- Отличные инструменты разработчика

### Задачи, которые решает React:

1. **Управление состоянием приложения**: React предоставляет механизмы для эффективного управления данными компонентов
2. **Обновление интерфейса**: Автоматическое обновление UI при изменении данных
3. **Модульность**: Создание переиспользуемых компонентов
4. **Тестируемость**: Компоненты легко тестировать изолированно
5. **SEO-оптимизация**: Возможность серверного рендеринга (SSR)

## 3. Анатомия React приложения

### Структура типичного React приложения:

```
my-react-app/
├── public/
│   ├── index.html          # Главный HTML файл
│   ├── favicon.ico         # Иконка сайта
│   └── manifest.json       # Метаданные приложения
├── src/
│   ├── components/         # Папка с компонентами
│   │   ├── Header.js
│   │   ├── Footer.js
│   │   └── Button.js
│   ├── pages/             # Страницы приложения
│   │   ├── Home.js
│   │   └── About.js
│   ├── styles/            # CSS файлы
│   │   └── App.css
│   ├── utils/             # Вспомогательные функции
│   ├── App.js             # Главный компонент
│   ├── index.js           # Точка входа в приложение
│   └── index.css          # Глобальные стили
├── package.json           # Зависимости и скрипты
└── README.md             # Документация проекта
```

### Ключевые файлы:

**index.html** — корневой HTML документ, содержит div с id="root", куда монтируется React приложение

**index.js** — точка входа, где происходит рендеринг главного компонента App в DOM

**App.js** — главный компонент приложения, содержит основную логику и структуру

**package.json** — содержит информацию о проекте, зависимостях и скриптах сборки

## 4. Настройка окружения

### Способы создания React приложения:

#### 1. Create React App (CRA) — Рекомендуемый способ для начинающих

```bash
# Установка через npx (рекомендуется)
npx create-react-app my-app
cd my-app
npm start

# Или через npm
npm create-react-app my-app

# Или через yarn
yarn create react-app my-app
```

#### 2. Vite — Быстрый современный инструмент сборки

```bash
npm create vite@latest my-react-app -- --template react
cd my-react-app
npm install
npm run dev
```

#### 3. Next.js — Full-stack React фреймворк

```bash
npx create-next-app@latest my-app
cd my-app
npm run dev
```

### Необходимые инструменты:

**Node.js** (версия 14 или выше) — JavaScript runtime для выполнения JavaScript на сервере **npm или yarn** — пакетные менеджеры для установки зависимостей **Редактор кода** — VS Code, WebStorm, Atom и др. **Браузер** — Chrome, Firefox с React Developer Tools

### Полезные расширения для VS Code:

- ES7+ React/Redux/React-Native snippets
- Bracket Pair Colorizer
- Auto Rename Tag
- Prettier - Code formatter
- React Developer Tools (для браузера)

## 5. Что такое Redux?

**Redux** — это предсказуемый контейнер состояния для JavaScript приложений. Хотя Redux не является частью React, он часто используется вместе с React для управления состоянием больших приложений.

### Основные принципы Redux:

#### 1. Единый источник истины (Single Source of Truth)

Все состояние приложения хранится в одном объекте состояния внутри единого store

#### 2. Состояние только для чтения (State is Read-Only)

Единственный способ изменить состояние — отправить action (действие)

#### 3. Изменения выполняются чистыми функциями (Changes are Made with Pure Functions)

Reducers — это чистые функции, которые принимают предыдущее состояние и action, возвращая новое состояние

### Основные концепции Redux:

**Store** — объект, который хранит состояние приложения **Action** — простой объект, описывающий что произошло **Reducer** — функция, которая определяет, как состояние изменяется в ответ на action **Dispatch** — метод для отправки actions в store

### Когда использовать Redux:

- Большое количество состояния приложения
- Состояние обновляется часто
- Логика обновления состояния сложная
- Приложение имеет средний или большой размер
- Много людей работают над кодом

### Альтернативы Redux:

- React Context API + useReducer
- Zustand
- Recoil
- MobX

## 6. Что такое JSX?

**JSX (JavaScript XML)** — это синтаксическое расширение JavaScript, которое позволяет писать HTML-подобный код внутри JavaScript. JSX делает код более читаемым и выразительным.

### Примеры JSX:

```jsx
// Простой JSX элемент
const element = <h1>Привет, мир!</h1>;

// JSX с переменными
const name = 'Иван';
const element = <h1>Привет, {name}!</h1>;

// JSX с атрибутами
const element = <img src="avatar.jpg" alt="Аватар" />;

// JSX с условным рендерингом
const element = (
  <div>
    {isLoggedIn ? <h1>Добро пожаловать!</h1> : <h1>Войдите в систему</h1>}
  </div>
);
```

### Правила JSX:

1. **JSX должен возвращать один корневой элемент**

```jsx
// Неправильно
return (
  <h1>Заголовок</h1>
  <p>Параграф</p>
);

// Правильно
return (
  <div>
    <h1>Заголовок</h1>
    <p>Параграф</p>
  </div>
);

// Или используя React Fragment
return (
  <>
    <h1>Заголовок</h1>
    <p>Параграф</p>
  </>
);
```

2. **Все теги должны быть закрыты**

```jsx
// Неправильно
<img src="image.jpg">
<input type="text">

// Правильно
<img src="image.jpg" />
<input type="text" />
```

3. **Атрибуты записываются в camelCase**

```jsx
// HTML
<div class="container" onclick="handleClick()">

// JSX
<div className="container" onClick={handleClick}>
```

### Встраивание выражений в JSX:

```jsx
const user = {
  firstName: 'Иван',
  lastName: 'Петров'
};

const element = (
  <h1>
    Привет, {user.firstName} {user.lastName}!
  </h1>
);
```

### JSX компилируется в вызовы React.createElement():

```jsx
// JSX код
const element = <h1 className="greeting">Привет, мир!</h1>;

// Компилируется в
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Привет, мир!'
);
```

## 7. Что такое Virtual DOM?

**Virtual DOM** — это концепция программирования, где виртуальное представление пользовательского интерфейса хранится в памяти и синхронизируется с "реальным" DOM при помощи библиотеки, такой как ReactDOM.

### Как работает Virtual DOM:

#### 1. Создание виртуального представления

Когда вы пишете JSX, React создает виртуальные объекты, представляющие DOM узлы

#### 2. Сравнение (Diffing)

При изменении состояния React создает новое виртуальное дерево и сравнивает его с предыдущим

#### 3. Обновление (Reconciliation)

React вычисляет минимальный набор изменений, необходимых для обновления реального DOM

### Преимущества Virtual DOM:

**Производительность**: Операции с JavaScript объектами быстрее, чем с DOM элементами

**Предсказуемость**: Декларативный подход делает поведение приложения более предсказуемым

**Кроссбраузерность**: React абстрагирует различия между браузерами

**Пакетирование обновлений**: React может группировать несколько изменений в одно обновление DOM

### Процесс работы Virtual DOM:

```
1. Состояние изменилось
2. React создает новое Virtual DOM дерево
3. React сравнивает новое дерево со старым (diffing)
4. React вычисляет минимальные изменения
5. React применяет изменения к реальному DOM
```

### Пример работы Virtual DOM:

```jsx
// Исходное состояние
<ul>
  <li>Элемент 1</li>
  <li>Элемент 2</li>
</ul>

// Новое состояние
<ul>
  <li>Элемент 1</li>
  <li>Элемент 2</li>
  <li>Элемент 3</li>
</ul>

// React поймет, что нужно добавить только один <li> элемент
// вместо перерисовки всего списка
```

## 8. Онлайновые редакторы для работы с React

### Repl.it (теперь Replit)

**Описание**: Облачная IDE с поддержкой множества языков программирования, включая React.

**Преимущества**:

- Не требует установки
- Поддержка коллаборативной разработки
- Встроенный терминал
- Автоматическое сохранение
- Множество готовых шаблонов

**Недостатки**:

- Может быть медленным на сложных проектах
- Ограниченная настройка окружения
- Требует интернет-соединения

**Лучше всего подходит для**: Обучения, быстрых экспериментов, совместной работы

### CodePen

**Описание**: Онлайн-редактор для фронтенд-разработки с живым предварительным просмотром.

**Преимущества**:

- Мгновенный просмотр результата
- Большое сообщество разработчиков
- Множество готовых примеров
- Простой интерфейс
- Поддержка препроцессоров

**Недостатки**:

- Ограничения в структуре проекта
- Сложно работать с многофайловыми проектами
- Ограниченная поддержка npm пакетов

**Лучше всего подходит для**: Создания небольших демонстраций, изучения концепций, экспериментов

### CodeSandbox

**Описание**: Мощный онлайн-редактор, специально оптимизированный для современной веб-разработки.

**Преимущества**:

- Полная поддержка npm пакетов
- Автоматическая настройка окружения
- Встроенный терминал и консоль
- Поддержка TypeScript из коробки
- Отличная производительность
- Интеграция с GitHub
- Поддержка различных фреймворков

**Недостатки**:

- Некоторые продвинутые функции требуют подписки
- Может быть избыточным для простых проектов

**Лучше всего подходит для**: Серьезной разработки, прототипирования, демонстрации проектов

### Другие редакторы

#### StackBlitz

- Использует WebAssembly для высокой производительности
- Поддержка Angular, React, Vue
- Интеграция с VS Code
- Отличная поддержка TypeScript

#### JSFiddle

- Простой и быстрый
- Хорош для небольших экспериментов
- Ограниченная поддержка современных фреймворков

#### Glitch

- Фокус на full-stack разработке
- Хорошая поддержка Node.js
- Социальные функции

#### Scrimba

- Интерактивные скринкасты
- Возможность редактировать код во время просмотра
- Образовательная направленность

### Сравнительная таблица редакторов:

|Характеристика|CodePen|CodeSandbox|Replit|StackBlitz|
|---|---|---|---|---|
|React поддержка|⭐⭐⭐|⭐⭐⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐⭐⭐|
|npm пакеты|❌|✅|✅|✅|
|Производительность|⭐⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐|⭐⭐⭐⭐⭐|
|Простота использования|⭐⭐⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐⭐|
|Совместная работа|⭐⭐⭐|⭐⭐⭐⭐|⭐⭐⭐⭐⭐|⭐⭐⭐|

## 9. Компоненты

### Что такое компонент?

**Компонент** — это независимая, переиспользуемая часть кода, которая возвращает React элемент, описывающий, что должно появиться на экране. Компоненты позволяют разбить пользовательский интерфейс на независимые, переиспользуемые части.

### Основные принципы компонентов:

**Инкапсуляция**: Каждый компонент содержит собственную логику и состояние **Переиспользуемость**: Компоненты можно использовать в разных частях приложения **Композиция**: Сложные компоненты создаются из простых **Однонаправленный поток данных**: Данные передаются от родителя к ребенку через props

### Функциональные компоненты

Функциональные компоненты — это JavaScript функции, которые принимают объект props в качестве аргумента и возвращают JSX.

#### Простой функциональный компонент:

```jsx
function Welcome(props) {
  return <h1>Привет, {props.name}!</h1>;
}

// Или стрелочная функция
const Welcome = (props) => {
  return <h1>Привет, {props.name}!</h1>;
};

// Использование
<Welcome name="Анна" />
```

#### Функциональный компонент с хуками:

```jsx
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Счетчик: ${count}`;
  }, [count]);

  return (
    <div>
      <p>Вы нажали {count} раз</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми меня
      </button>
    </div>
  );
}
```

#### Преимущества функциональных компонентов:

- Более простой и читаемый код
- Меньше boilerplate кода
- Лучшая производительность
- Поддержка React Hooks
- Легче тестировать

### Классовые компоненты

Классовые компоненты — это ES6 классы, которые наследуются от React.Component и должны содержать метод render().

#### Простой классовый компонент:

```jsx
import React, { Component } from 'react';

class Welcome extends Component {
  render() {
    return <h1>Привет, {this.props.name}!</h1>;
  }
}
```

#### Классовый компонент с состоянием:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `Счетчик: ${this.state.count}`;
  }

  componentDidUpdate() {
    document.title = `Счетчик: ${this.state.count}`;
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>Вы нажали {this.state.count} раз</p>
        <button onClick={this.increment}>
          Нажми меня
        </button>
      </div>
    );
  }
}
```

#### Методы жизненного цикла классовых компонентов:

- **componentDidMount()** — вызывается после монтирования компонента
- **componentDidUpdate()** — вызывается после обновления компонента
- **componentWillUnmount()** — вызывается перед размонтированием компонента
- **shouldComponentUpdate()** — определяет, нужно ли обновлять компонент

### Отличия функциональных и классовых компонентов

#### Синтаксис:

```jsx
// Функциональный
const MyComponent = (props) => {
  return <div>Hello {props.name}</div>;
};

// Классовый
class MyComponent extends Component {
  render() {
    return <div>Hello {this.props.name}</div>;
  }
}
```

#### Состояние:

```jsx
// Функциональный (с хуками)
const MyComponent = () => {
  const [count, setCount] = useState(0);
  return <div>{count}</div>;
};

// Классовый
class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }
  
  render() {
    return <div>{this.state.count}</div>;
  }
}
```

#### Методы жизненного цикла:

```jsx
// Функциональный (с хуками)
const MyComponent = () => {
  useEffect(() => {
    // componentDidMount
    console.log('Компонент смонтирован');
    
    return () => {
      // componentWillUnmount
      console.log('Компонент будет размонтирован');
    };
  }, []);
  
  return <div>My Component</div>;
};

// Классовый
class MyComponent extends Component {
  componentDidMount() {
    console.log('Компонент смонтирован');
  }
  
  componentWillUnmount() {
    console.log('Компонент будет размонтирован');
  }
  
  render() {
    return <div>My Component</div>;
  }
}
```

### Сравнительная таблица:

|Характеристика|Функциональные|Классовые|
|---|---|---|
|Синтаксис|Проще|Более verbose|
|Производительность|Лучше|Немного хуже|
|Состояние|useState hook|this.state|
|Жизненный цикл|useEffect hook|Методы жизненного цикла|
|Поддержка|Активная|Legacy|
|Тестирование|Проще|Сложнее|
|Размер бандла|Меньше|Больше|

### Рекомендации по выбору:

**Используйте функциональные компоненты когда**:

- Создаете новый проект
- Компонент не требует сложной логики состояния
- Хотите использовать современные возможности React
- Важна производительность

**Используйте классовые компоненты когда**:

- Поддерживаете старый код
- Нужны специфичные методы жизненного цикла
- Работаете с legacy кодом

React команда рекомендует использовать функциональные компоненты с хуками для всех новых проектов, так как они проще, более производительны и представляют будущее React разработки.